#labels Linux,Kernel,Makefile
#Linux Kernel Makefile Analysis.

= Linux内核源代码中的Makefile分析 =

== 概述 ==
Makefile包括五部分：

　* Makefile                 顶层Makefile文件
　* .config                  内核配置文件
　* arch/$(ARCH)/Makefile    机器体系Makefile文件
　* scripts/Makefile.*       所有内核Makefiles共用规则
　* kbuild Makefiles         其它Makefile文件

通过内核配置操作产生.config文件，顶层Makefile文件读取该文件的配置。

顶层Makefile文件负责产生两个主要的程序：vmlinux (内核image)和模块。顶层Makefile文件根据内核配置，通过递归编译内核代码树子目录建立这两个文件。顶层Makefile文件文本一个名为 arch/$(ARCH)/Makefile的机器体系Makefile文件。机器体系Makefile文件为顶层Makefile文件提供与机器相关的信息。

每一个子目录有一个Makefile文件，子目录Makefile文件根据上级目录Makefile文件命令启动编译。这些Makefile使用.config文件配置数据构建各种文件列表，并使用这些文件列表编译内嵌或模块目标文件。

scripts/Makefile.*包含了所有的定义和规则，与Makefile文件一起编译出内核程序。

== 入口点的问题 ==

默认的Makefile的入口点是第一条规则。而Linux内核的Makefile的第一条规则是这样的：

除去上面一长串赋值语句，来到：
{{{
PHONY := _all
_all:

}}}
是一条空规则。奇怪的是，下面不远处有如下规则：

{{{
ifeq ($(KBUILD_EXTMOD),)
_all: all
else
_all: modules
endif

}}}
也就是说目标_all被写了两遍。

原因如下：一般Makefile是不允许一个目标被重复写两遍的，如：

{{{
a:
    echo a1
a:
    echo a2
}}}

这种情况会生成一条警告，说一条规则将被忽略。但如果第一条规则是一条空规则则是可以的，如：
{{{

a:
a:
    echo a2
}}}

而且还有如下用法：
{{{

b:
    echo b
a:
    echo a
}}}

此Makefile如果直接make将会执行echo b，因为这是第一条规则，会被当成默认规则。但如果写成下面的样子：

{{{
a:
b:
    echo b
a:
    echo a
}}}

由于第一条空规则的存在，echo a会被当成默认规则执行。因此Linux内核中的Makefile的_all可以做如下解释：

真正的入口点是:
{{{

ifeq ($(KBUILD_EXTMOD),)
_all: all
else
_all: modules
endif
}}}

这不必保证这几行代码是第一条规则，之前还可以插入任何内容，只需要保证空规则

{{{
PHONY := _all
_all:

}}}
是整个文件的第一条规则，正真入口点处的规则便会被当成默认规则被执行。
文章出处：[http://www.diybl.com/course/6_system/linux/Linuxjs/200896/139654.html DIY部落]