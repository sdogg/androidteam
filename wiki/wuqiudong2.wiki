#summary One-sentence summary of this page.

= 触摸屏驱动移植 =

Add your content here.


{{{
 * 在 linux2.6.25 中没有提供 s3c2410 的驱动，所以我们要新建驱动文件，从网上下载s3c2410_ts.c与s3c2410_ts.h两个文件,
s3c2410_ts.c内容如下：
#include <linux/delay.h>
#include <linux/errno.h>
#include <linux/kernel.h>
#include <linux/interrupt.h>
#include <linux/module.h>
#include <linux/slab.h>
#include <linux/input.h>
#include <linux/init.h>
#include <linux/serio.h>
#include <linux/irq.h>
#include <linux/delay.h>
#include <linux/clk.h>
#include <asm/io.h>
#include <asm/irq.h>
#include <asm/plat-s3c/regs-adc.h>
#include <asm/arch/regs-gpio.h>
#include <asm/arch/regs-clock.h>
#include <asm/plat-s3c24xx/devs.h>
#include <asm/plat-s3c24xx/clock.h>
#include <asm/arch-s3c2410/s3c2410_ts.h>


#define S3C2410_GPG12         S3C2410_GPIONO(S3C2410_GPIO_BANKG, 12)
#define S3C2410_GPG13         S3C2410_GPIONO(S3C2410_GPIO_BANKG, 13)
#define S3C2410_GPG14         S3C2410_GPIONO(S3C2410_GPIO_BANKG, 14)
#define S3C2410_GPG15         S3C2410_GPIONO(S3C2410_GPIO_BANKG, 15)

/* For ts.dev.id.version */
#define S3C2410TSVERSION	0x0101

#define WAIT4INT(x)  (((x)<<8) | \
		     S3C2410_ADCTSC_YM_SEN | S3C2410_ADCTSC_YP_SEN | S3C2410_ADCTSC_XP_SEN | \
		     S3C2410_ADCTSC_XY_PST(3))

#define AUTOPST	     (S3C2410_ADCTSC_YM_SEN | S3C2410_ADCTSC_YP_SEN | S3C2410_ADCTSC_XP_SEN | \
		     S3C2410_ADCTSC_AUTO_PST | S3C2410_ADCTSC_XY_PST(0))

#define DEBUG_LVL    KERN_DEBUG

MODULE_AUTHOR("Arnaud Patard <arnaud.patard at rtp-net.org>");
MODULE_DESCRIPTION("s3c2410 touchscreen driver");
MODULE_LICENSE("GPL");

/*
 * Definitions & global arrays.
 */


static char *s3c2410ts_name = "s3c2410 TouchScreen";

/*
 * Per-touchscreen data.
 */

struct s3c2410ts {
	struct input_dev *dev;
	long xp;
	long yp;
	int count;
	int shift;
};

static struct s3c2410ts ts;
static void __iomem *base_addr;

static inline void s3c2410_ts_connect(void)
{
	s3c2410_gpio_cfgpin(S3C2410_GPG12, S3C2410_GPG12_XMON);
	s3c2410_gpio_cfgpin(S3C2410_GPG13, S3C2410_GPG13_nXPON);
	s3c2410_gpio_cfgpin(S3C2410_GPG14, S3C2410_GPG14_YMON);
	s3c2410_gpio_cfgpin(S3C2410_GPG15, S3C2410_GPG15_nYPON);
}

static void touch_timer_fire(unsigned long data)
{
  	unsigned long data0;
  	unsigned long data1;
	int updown;

  	data0 = ioread32(base_addr+S3C2410_ADCDAT0);
  	data1 = ioread32(base_addr+S3C2410_ADCDAT1);

 	updown = (!(data0 & S3C2410_ADCDAT0_UPDOWN)) && (!(data1 & S3C2410_ADCDAT0_UPDOWN));

 	if (updown) {
 		if (ts.count != 0) {
 			ts.xp >>= ts.shift;
 			ts.yp >>= ts.shift;

#ifdef CONFIG_TOUCHSCREEN_S3C2410_DEBUG
 			{
 				struct timeval tv;
 				do_gettimeofday(&tv);
 				printk(DEBUG_LVL "T: %06d, X: %03ld, Y: %03ld\n", (int)tv.tv_usec, ts.xp, ts.yp);
 			}
#endif

 			input_report_abs(ts.dev, ABS_X, ts.xp);
 			input_report_abs(ts.dev, ABS_Y, ts.yp);

 			input_report_key(ts.dev, BTN_TOUCH, 1);
 			input_report_abs(ts.dev, ABS_PRESSURE, 1);
 			input_sync(ts.dev);
 		}

 		ts.xp = 0;
 		ts.yp = 0;
 		ts.count = 0;

 		iowrite32(S3C2410_ADCTSC_PULL_UP_DISABLE | AUTOPST, base_addr+S3C2410_ADCTSC);
 		iowrite32(ioread32(base_addr+S3C2410_ADCCON) | S3C2410_ADCCON_ENABLE_START, base_addr+S3C2410_ADCCON);
 	} else {
 		ts.count = 0;

 		input_report_key(ts.dev, BTN_TOUCH, 0);
 		input_report_abs(ts.dev, ABS_PRESSURE, 0);
 		input_sync(ts.dev);

 		iowrite32(WAIT4INT(0), base_addr+S3C2410_ADCTSC);
 	}
}

static struct timer_list touch_timer =
		TIMER_INITIALIZER(touch_timer_fire, 0, 0);

static irqreturn_t stylus_updown(int irq, void *dev_id)
{
	unsigned long data0;
	unsigned long data1;
	int updown;

	data0 = ioread32(base_addr+S3C2410_ADCDAT0);
	data1 = ioread32(base_addr+S3C2410_ADCDAT1);

	updown = (!(data0 & S3C2410_ADCDAT0_UPDOWN)) && (!(data1 & S3C2410_ADCDAT0_UPDOWN));

	/* TODO we should never get an interrupt with updown set while
	 * the timer is running, but maybe we ought to verify that the
	 * timer isn't running anyways. */

	if (updown)
		touch_timer_fire(0);

	return IRQ_HANDLED;
}


static irqreturn_t stylus_action(int irq, void *dev_id)
{
	unsigned long data0;
	unsigned long data1;

	data0 = ioread32(base_addr+S3C2410_ADCDAT0);
	data1 = ioread32(base_addr+S3C2410_ADCDAT1);

	ts.xp += data0 & S3C2410_ADCDAT0_XPDATA_MASK;
	ts.yp += data1 & S3C2410_ADCDAT1_YPDATA_MASK;
	ts.count++;

    if (ts.count < (1<<ts.shift)) {
		iowrite32(S3C2410_ADCTSC_PULL_UP_DISABLE | AUTOPST, base_addr+S3C2410_ADCTSC);
		iowrite32(ioread32(base_addr+S3C2410_ADCCON) | S3C2410_ADCCON_ENABLE_START, base_addr+S3C2410_ADCCON);
	} else {
		mod_timer(&touch_timer, jiffies+1);
		iowrite32(WAIT4INT(1), base_addr+S3C2410_ADCTSC);
	}

	return IRQ_HANDLED;
}

static struct clk	*adc_clock;

/*
 * The functions for inserting/removing us as a module.
 */

static int __init s3c2410ts_probe(struct platform_device *pdev)
{
	struct s3c2410_ts_mach_info *info;
	struct input_dev *input_dev;

	info = ( struct s3c2410_ts_mach_info *)(pdev->dev.platform_data);

	if (!info)
	{
		printk(KERN_ERR "Hm... too bad : no platform data for ts\n");
		return -EINVAL;
	}

#ifdef CONFIG_TOUCHSCREEN_S3C2410_DEBUG
	printk(DEBUG_LVL "Entering s3c2410ts_init\n");
#endif

	adc_clock = clk_get(NULL, "adc");
	if (!adc_clock) {
		printk(KERN_ERR "failed to get adc clock source\n");
		return -ENOENT;
	}
	clk_enable(adc_clock);

#ifdef CONFIG_TOUCHSCREEN_S3C2410_DEBUG
	printk(DEBUG_LVL "got and enabled clock\n");
#endif

	base_addr=ioremap(S3C2410_PA_ADC,0x20);
	if (base_addr == NULL) {
		printk(KERN_ERR "Failed to remap register block\n");
		return -ENOMEM;
	}

	/* Configure GPIOs */
	s3c2410_ts_connect();

	if ((info->presc&0xff) > 0)
		iowrite32(S3C2410_ADCCON_PRSCEN | S3C2410_ADCCON_PRSCVL(info->presc&0xFF),\
			     base_addr+S3C2410_ADCCON);
	else
		iowrite32(0,base_addr+S3C2410_ADCCON);


	/* Initialise registers */
	if ((info->delay&0xffff) > 0)
		iowrite32(info->delay & 0xffff,  base_addr+S3C2410_ADCDLY);

	iowrite32(WAIT4INT(0), base_addr+S3C2410_ADCTSC);

	/* Initialise input stuff */
	memset(&ts, 0, sizeof(struct s3c2410ts));
	input_dev = input_allocate_device();

	if (!input_dev) {
		printk(KERN_ERR "Unable to allocate the input device !!\n");
		return -ENOMEM;
	}

	ts.dev = input_dev;
	ts.dev->evbit[0] = BIT(EV_SYN) | BIT(EV_KEY) | BIT(EV_ABS);
	ts.dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
	input_set_abs_params(ts.dev, ABS_X, 0, 0x3FF, 0, 0);
	input_set_abs_params(ts.dev, ABS_Y, 0, 0x3FF, 0, 0);
	input_set_abs_params(ts.dev, ABS_PRESSURE, 0, 1, 0, 0);

	//ts.dev->private = &ts;
	ts.dev->name = s3c2410ts_name;
	ts.dev->id.bustype = BUS_RS232;
	ts.dev->id.vendor = 0xDEAD;
	ts.dev->id.product = 0xBEEF;
	ts.dev->id.version = S3C2410TSVERSION;

	ts.shift = info->oversampling_shift;

	/* Get irqs */
	if (request_irq(IRQ_ADC, stylus_action, IRQF_SAMPLE_RANDOM,
		"s3c2410_action", ts.dev)) {
		printk(KERN_ERR "s3c2410_ts.c: Could not allocate ts IRQ_ADC !\n");
		iounmap(base_addr);
		return -EIO;
	}
	if (request_irq(IRQ_TC, stylus_updown, IRQF_SAMPLE_RANDOM,
			"s3c2410_action", ts.dev)) {
		printk(KERN_ERR "s3c2410_ts.c: Could not allocate ts IRQ_TC !\n");
		iounmap(base_addr);
		return -EIO;
	}

	printk(KERN_INFO "%s successfully loaded\n", s3c2410ts_name);

	/* All went ok, so register to the input system */
	input_register_device(ts.dev);

	return 0;
}

static int s3c2410ts_remove(struct platform_device *pdev)
{
	disable_irq(IRQ_ADC);
	disable_irq(IRQ_TC);
	free_irq(IRQ_TC,ts.dev);
	free_irq(IRQ_ADC,ts.dev);

	if (adc_clock) {
		clk_disable(adc_clock);
		clk_put(adc_clock);
		adc_clock = NULL;
	}

	input_unregister_device(ts.dev);
	iounmap(base_addr);

	return 0;
}

static struct platform_driver s3c2410ts_driver = {
       .driver         = {
	       .name   = "s3c2410-ts",
	       .owner  = THIS_MODULE,
       },
       .probe          = s3c2410ts_probe,
       .remove         = s3c2410ts_remove,
};


static int __init s3c2410ts_init(void)
{
	return platform_driver_register(&s3c2410ts_driver);
}

static void __exit s3c2410ts_exit(void)
{
	platform_driver_unregister(&s3c2410ts_driver);
}

module_init(s3c2410ts_init);
module_exit(s3c2410ts_exit);


s3c2410_ts.h 的内容如下：
#ifndef __ASM_ARM_TS_H
#define __ASM_ARM_TS_H
struct s3c2410_ts_mach_info {
       int             delay;
       int             presc;
       int             oversampling_shift;
};
void __init set_s3c2410ts_info(struct s3c2410_ts_mach_info *hard_s3c2410ts_info);
#endif /* __ASM_ARM_TS_H */



将s3c2410_ts.c 文件拷到 linux2.6.25/drivers/input/touchscreen 目录下，头文件则拷到源码包的include/asm/arch下,


第一：我们需要修改 linux2.6.25/drivers/input/touchscreen 目录下的 makefile 文件，在文件的最后添加 ： 

obj-$(CONFIG_TOUCHSCREEN_S3C2410) += s3c2410_ts.o 

第二：我们需要修改 linux2.6.25/ drivers/input/touchscreen/Kconfig 中添加： 

     config TOUCHSCREEN_S3C2410 

     tristate "Samsung S3C2410 touchscreen input driver" 

     depends on ARCH_SMDK2410 && INPUT && INPUT_TOUCHSCREEN 

     select SERIO 

     help 

     Say Y here if you have the s3c2410 touchscreen. 

     If unsure, say N. 

     To compile this driver as a module, choose M here: the 

     module will be called s3c2410_ts. 

     

config TOUCHSCREEN_S3C2410_DEBUG 

     boolean "Samsung S3C2410 touchscreen debug messages" 

     depends on TOUCHSCREEN_S3C2410 

     help 

     Select this if you want debug messages 

修改完成以后，在我们配置内核的时候，就会增加关系s3c2410的触摸屏配置，我们选择上这些配置就可以把驱动增加进去了 

Device drivers --> 

          Input device support -->

                     Touchscreens -->

                      <*>Samsung S3C2410 touchscreen input driver 

                      []Samsung s3c2410 touchscreen debug message 

第三：在 /linux-2.6.25/arch/arm/mach-s3c2410/mach-smdk2410.c, 中增加如下内容： 

#include <asm/arch/s3c2410_ts.h>

     static struct s3c2410_ts_mach_info s3c2410_ts_cfg __initdata = { 

     .delay = 10000, 

    .presc = 49,

     .oversampling_shift = 2, 

     }; 

     在smdk2410_devices结构中，添加： 

     &s3c_device_ts, 

     在smdk2410_map_io函数中添加： 

     set_s3c2410ts_info(&s3c2410_ts_cfg); 

第四：在 /linux-2.6.25/ arch/arm/mach-s3c2410/devs.h 文件中添加： 

     extern struct platform_device s3c_device_ts; 

第五：在arch/arm/mach-s3c2410/devs.c文件中添加如下几行： 

    /* Touchscreen */ 

#include <asm/arch/s3c2410_ts.h>

    static struct s3c2410_ts_mach_info s3c2410ts_info; 

    void __init set_s3c2410ts_info(struct s3c2410_ts_mach_info *hard_s3c2410ts_info)
{ 

memcpy(&s3c2410ts_info,hard_s3c2410ts_info,sizeof(struct s3c2410_ts_mach_info)); 

} 

EXPORT_SYMBOL(set_s3c2410ts_info); 

struct platform_device s3c_device_ts = { 

.name = "s3c2410-ts", 

.id = -1, 

.dev = { 

.platform_data = &s3c2410ts_info, 

} 

}; 

EXPORT_SYMBOL(s3c_device_ts); 

第六：将regs-adc.h这个头文件里的#define S3C2410_ADCTSC_XY_PST (0x3<<0),#改为define S3C2410_ADCTSC_XY_PST(x) (((x)&0x3)<<0),//设置AD转换
第七：配置内核：
make menuconfig 
Device drivers –>
Input device support –>
   Touchscreen interface       
(240) Horizontal screen resolution 
(360) Vertical screen resolution 
   Event interface             
   Event debugging
Touchscreens –>
Samsung S3C2410 touchscreen input driver
[*]Samsung s3c2410 touchscreen debug message 

第八：编译内核
make zImage
在启动提示中可以看到如下结果:
内核启动信息里有

s3c2410 TouchScreen successfully loaded 

input: s3c2410 TouchScreen as /class/input/input0

驱动移植成功，剩下的就是测试触摸屏驱动了

第九：测试
刚开始找不到触摸屏的设备文件，只知道主次设备号是13，64，后来在/dev/input/下用ls -l后查看到event0的设备号刚好也是13，64，
于是cat event0,但是日志上显示的是乱码，
于是再echo 8 > /proc/sys/kernel/printk，修改一下打印级别，然后按触摸屏，终端上就显示触摸处的x和y坐标了，按左下端显示为原点坐标


}}}