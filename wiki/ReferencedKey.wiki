#labels 参考答案
#参考答案.

= 参考答案 =

 * i386实模式下是如何解决20位地址空间和16位段寄存器之间的不匹配问题的？
{{{ 
答:
实模式下
地址总线：20位
内存范围：0~1MB
逻辑地址 = 段地址 + 段内偏移
段地址 = 段寄存器中的值*16 （或左移4位）

8086中，数据总线的宽度是16位（通常和ALU一样），地址总线为20位，寻址空间为1M。
因此，在8086中使用了分段的方法来把16位的地址映射为20位的物理地址。
16位的段寄存器对应地址总线的高16位，段地址左移4位再加上访存指令中的16位地址，就形成了真正的20位的物理地址。
但在这种机制下，由段寄存器确定一个“基地址”，一个进程总是可以访问由此开始的64K字节的连续地址空间，且无法加以限制。
}}}

 * i386保护模式下的段寄存器的内容与实模式下段寄存器的内容一样么？如何解释？ 
{{{
实模式下内存是按es,ds这些段寄存器来分段的,段寄存器直接保存段地址.
在保护模式下段寄存器称作段选择器，与GDT表配合使用.
CPU按照下面过程实现从指令中的32位逻辑地址到32位物理地址的转换：
    1.首先根据指令的性质来确定该使用哪一个段寄存器。
    2.根据段寄存器的内容，找到相应的“段描述结构”。
    3.从“段描述结构”中得到基地址。
    4.将指令中的地址作为位移，与段描述结构中规定的段长度相比，看是否越界；
    5.根据指令的性质和段描述符中的访问权限来确定是否越权；
    6.最后才将指令中的地址作为位移，与段基地址相加，得到物理地址。
    同时，在上面过程中，由于有对访问权限的检查，就实现了保护。

}}}
 * __USER_CS、 __USER_DS的值分别是多少？它们分别对应GDT表中的哪一项？RPL(课件中可能错了，应该是DPL)分别是多少，对应Linux的哪个级别（用户级还是内核级）？
{{{
__USER_CS=0x33
__USER_DS=0x2b
他们分别对应GDT表中的用户代码段和用户数据段
DPL都是3，对应linux的用户级。
}}}
 * Linux为什么要引入pidhash表？
{{{
在一些情况下，内核必须能从进程的PID得出对应的进程描述符指针。例如kill系统调用
为了加速查找，引入了pid_hash散列表
}}}
 * 在传统的UNIX系统中，创建子进程时会复制父进程的所有资源，代价比较高，现代UNIX系统中引入了哪几项技术来解决这个问题？
{{{
传统的UNIX操作系统采用统一的方式来创建进程，子进程复制父进程所拥有的资源。
这样有一些缺点：创建过程慢、效率低。
事实上，子进程复制的很多资源是不会使用到的，现代UNIX内核通过引入三种不同的机制来解决这个问题：
1、写时复制技术，Copy-On-Writing，COW写时复制技术允许父子进程能读相同的物理页。
只要两者有一个进程试图写一个物理页，内核就把这个页的内容拷贝到一个新的物理页，并把这个新的物理页分配给正在写的进程。
2、轻量级进程允许父子进程共享许多数据结构，如页表、打开的文件列表、信号处理等。
3、vfork，使用vfork创建的新进程能够共享父进程的内存地址空间。父进程在这个过程中被阻塞，直到子进程退出或者执行一个新的程序
}}}
 * Linux2.4.18中，名词解释：epoch、基本时间片
{{{
每个进程被创建时都被赋予一个时间片。时钟中断递减当前运行进程的时间片，当进程的时间片被用完时，它必须等待重新赋予时间片才能有机会运行。
Linux2.4 调度器保证只有当所有 RUNNING 进程的时间片都被用完之后，才对所有进程重新分配时间片。
这段时间被称为一个 epoch。这种设计保证了每个进程都有机会得到执行。
(Linux调度器发展简述 http://www.ibm.com/developerworks/cn/linux/l-cn-scheduler/ )
每个进程有一个基本时间片，通过nice计算,时间片/epoch到期时，计算新时间片.
通常，基本时间片的值 为6，由于时钟中断大约10ms左右，因此基本时间片的长度大约60ms
}}}
 * Linux2.6.26中，名词解释：CFS
{{{
理想的调度，所有的任务都是公平的。等速度的运行每个任务。 
cfs就是通过追踪这个vruntime来进行任务调度的。它总是选 vruntime最小的进程来运行。
CFS抛弃了active/expire数组，而使用红黑树选取下一个被调度进程。所有状态为RUNABLE的进程都被插入红黑树。在每个调度点，CFS调度器都会选择红黑树的最左边的叶子节点作为下一个将获得cpu的进程。这样总是选 vruntime最小的进程来运行。
}}}
 * Linux2.6.17中，名词解释：双队列
{{{
采用双队列分成active/expire两个数组，分别按照优先级组队。
}}}
== References ==
 * [http://www.chinaitpower.com/A200507/2005-07-27/174010.html Intel X86系列的寻址方式总结]
 * [http://www.ibm.com/developerworks/cn/linux/l-cn-scheduler/ Linux调度器发展简述]