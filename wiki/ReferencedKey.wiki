#labels 参考答案
#参考答案.

= 参考答案 =

 * i386实模式下是如何解决20位地址空间和16位段寄存器之间的不匹配问题的？
{{{ 
答:
实模式下
地址总线：20位
内存范围：0~1MB
逻辑地址 = 段地址 + 段内偏移
段地址 = 段寄存器中的值*16 （或左移4位）

8086中，数据总线的宽度是16位（通常和ALU一样），地址总线为20位，寻址空间为1M。因此，在8086中使用了分段的方法来把16位的地址映射为20位的物理地址。16位的段寄存器对应地址总线的高16位，段地址左移4位再加上访存指令中的16位地址，就形成了真正的20位的物理地址。但在这种机制下，由段寄存器确定一个“基地址”，一个进程总是可以访问由此开始的64K字节的连续地址空间，且无法加以限制。
}}}

 * i386保护模式下的段寄存器的内容与实模式下段寄存器的内容一样么？如何解释？ 
{{{
实模式下内存是按es,ds这些段寄存器来分段的,段寄存器直接保存段地址.
在保护模式下段寄存器称作段选择器，与GDT表配合使用.
CPU按照下面过程实现从指令中的32位逻辑地址到32位物理地址的转换：
    1.首先根据指令的性质来确定该使用哪一个段寄存器。
    2.根据段寄存器的内容，找到相应的“段描述结构”。
    3.从“段描述结构”中得到基地址。
    4.将指令中的地址作为位移，与段描述结构中规定的段长度相比，看是否越界；
    5.根据指令的性质和段描述符中的访问权限来确定是否越权；
    6.最后才将指令中的地址作为位移，与段基地址相加，得到物理地址。
    同时，在上面过程中，由于有对访问权限的检查，就实现了保护。

}}}
 * __USER_CS、 __USER_DS的值分别是多少？它们分别对应GDT表中的哪一项？RPL(课件中可能错了，应该是DPL)分别是多少，对应Linux的哪个级别（用户级还是内核级）？
{{{
__USER_CS=0x33
__USER_DS=0x2b
他们分别对应GDT表中的用户代码段和用户数据段
DPL都是3，对应linux的用户级。
}}}

== References ==
 * [http://www.chinaitpower.com/A200507/2005-07-27/174010.html Intel X86系列的寻址方式总结]