基于2.6.25内核的LCD驱动程序分析1.

= Introduction =

platform_device 和 platform_driver


= Details =
从2.6版本开始引入了platform这个概念, platform可以理解为一种设备类型，就像字符设备、块设备、网络设备一样，为了向内核添加一个platform设备，应该填写两个数据结构 一个为platform_device 另一个为platform_driver 
* 先来介绍platform_device 
  platform_device 定义在文件 kernel\include\linux\platform_device.h 中  
  定义如下：
  {{{
  struct platform_device {
	const char	* name;
	int		id;
	struct device	dev;
	u32		num_resources;
	struct resource	* resource;
};
  }}}
  该结构一个重要的元素是resource，该元素存入了最为重要的设备资源信息，定义在kernel\include\linux\ioport.h中，定义如下：
 {{{
 struct resource {
	resource_size_t start;
	resource_size_t end;
	const char *name;
	unsigned long flags;
	struct resource *parent, *sibling, *child;
};
}}}
 下面我们以s3c2410的lcd为例来具体讲解下 
  在 arch/arm/plat-s3c24xx/devs.c中 可以看到填写 lcd的代码 如下：
{{{
static u64 s3c_device_lcd_dmamask = 0xffffffffUL;

struct platform_device s3c_device_lcd = {
	.name		  = "s3c2410-lcd",
	.id		  = -1,
	.num_resources	  = ARRAY_SIZE(s3c_lcd_resource),
	.resource	  = s3c_lcd_resource,
	.dev              = {
		.dma_mask		= &s3c_device_lcd_dmamask,
		.coherent_dma_mask	= 0xffffffffUL
	}
};
}}}
{{{
/* LCD Controller */

static struct resource s3c_lcd_resource[] = {
	[0] = {
		.start = S3C24XX_PA_LCD,
		.end   = S3C24XX_PA_LCD + S3C24XX_SZ_LCD - 1,
		.flags = IORESOURCE_MEM,
	},
	[1] = {
		.start = IRQ_LCD,
		.end   = IRQ_LCD,
		.flags = IORESOURCE_IRQ,
	}

};
}}}

 
  